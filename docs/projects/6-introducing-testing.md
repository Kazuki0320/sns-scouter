# テストを導入する

repomix にて、 https://github.com/Kazuki0320/sns-scouter の全体像を作成

プロンプト

```
上記プロジェクトに、新しくテストの仕組みを導入したいと考えています。
まず、何をどうテストした方がいいかとどの程度テストするべきか、ツールは何が候補に上がるかの要件定義書を作成してください。
```

# テスト導入の要件定義書

## 1. はじめに

本要件定義書は、SNSアカウントのスコア算出アプリケーション「sns-scouter」に、新たにテストの仕組みを導入するにあたり、テスト対象、テストレベル、テストツールなどの要件を明確にすることを目的とします。

## 2. テストの目的

- アプリケーションの品質向上
- バグの早期発見と修正コストの削減
- 開発チームの自信向上
- リファクタリングや機能追加時の安全性確保

## 3. テスト対象

以下のカテゴリに対してテストを実施します。

### 3.1. ユニットテスト

- **関数・コンポーネントのロジック**:
  - `src/app/calc/ScouterCalculator.tsx` 内の戦闘力計算関数 (`calculateBattlePower`, `getBattlePower`)
  - `src/components/ui/Form.tsx` 内の入力値のバリデーションと状態管理
  - `src/components/ui/ShareButton.tsx` 内のシェアURL生成ロジック
  - その他、独立した機能を持つ関数やロジック
- **UIコンポーネントのレンダリングと基本的な振る舞い**:
  - `src/components/ui/Button.tsx`: Propsに応じた表示と基本的なイベントハンドリング
  - `src/components/ui/ExperimentSpeechBubble.tsx`: Propsに応じた表示
  - `src/components/ui/SpeechBubble.tsx`: Propsに応じた表示
  - その他、UIの基本的な表示ロジックを持つコンポーネント

### 3.2. 統合テスト

- **ページ間の遷移とデータの流れ**:
  - フォーム (`src/app/form/page.tsx`, `src/components/ui/Form.tsx`) から結果表示 (`src/app/result/page.tsx`) へのデータの受け渡しと表示
  - ローディング画面 (`src/app/result/loading.tsx`) の表示と非同期処理完了後の画面遷移
- **コンポーネント間の連携**:
  - フォームコンポーネントと戦闘力計算ロジックの連携
  - 結果表示コンポーネントとシェアボタンコンポーネントの連携
- **外部サービスとの連携 (モック化)**:
  - 現状、外部API連携はありませんが、将来的にAPI連携が発生した場合、そのインターフェースに対するテスト（モックを用いた疎通確認）

### 3.3. E2E (End-to-End) テスト

- **主要なユーザーシナリオの網羅**:
  - ユーザーがトップページ (`src/app/page.tsx`) からフォロワー数を入力し、結果ページ (`src/app/result/page.tsx`) を経てシェアボタン (`src/components/ui/ShareButton.tsx`) をクリックするまでの流れ
  - エラーハンドリングのテスト（例：不正な入力値に対する挙動）
  - ローディング画面の表示から結果画面への遷移を含むシナリオ

## 4. テストレベルと範囲

- **ユニットテスト**:
  - **目標**: 主要な関数・コンポーネントに対して網羅率80%以上を目指します。特にビジネスロジック (`ScouterCalculator`) やフォームのバリデーションなど、アプリケーションの中核となる部分を重点的にテストします。
  - **範囲**: 個々の関数やコンポーネントの独立した振る舞いを検証します。外部依存はモック化します。
- **統合テスト**:
  - **目標**: 主要な機能間の連携が正しく行われることを確認します。重要なデータフローやコンポーネント間の相互作用をテストします。
  - **範囲**: 複数のユニットが組み合わさった際の動作を検証します。必要に応じて、依存するモジュールをモック化します。
- **E2Eテスト**:
  - **目標**: 主要なユーザーシナリオが正常に動作することを確認します。クリティカルなパスを重点的にテストします。
  - **範囲**: 実際のブラウザ環境で、アプリケーション全体を通してユーザーの操作をシミュレートします。

## 5. テストツール候補

### 5.1. テストフレームワーク

- **Jest**:
  - Reactエコシステムで広く利用されているJavaScriptテストフレームワーク。
  - ユニットテストと統合テストに適しています。
  - モック機能、スナップショットテスト、カバレッジ計測などの機能が豊富です。
  - Next.jsとの相性も良好です。
- **React Testing Library**:
  - ユーザー視点でのテストを重視したライブラリ。
  - コンポーネントの内部実装ではなく、ユーザーがどのように操作するかをテストします。
  - ユニットテスト、統合テスト、E2Eテストの一部（UIコンポーネントのレンダリング検証）で利用できます。

### 5.2. E2Eテストツール

- **Playwright**:
  - Microsoftが開発したE2Eテストフレームワーク。
  - Chromium, Firefox, WebKitなど複数のブラウザをサポートしています。
  - 自動待機、トレースビューワー、codegenなどの強力な機能があります。
  - Next.jsアプリケーションのE2Eテストに適しています。
- **Cypress**:
  - 開発者体験に優れたE2Eテストフレームワーク。
  - リアルタイムリロード、Time Travel Debuggingなどの機能が特徴です。
  - JavaScriptベースで記述できます。

### 5.3. カバレッジ計測ツール

- **Jestに内蔵**: Jestは標準でカバレッジ計測機能を備えています。
- **Istanbul (nyc)**: より詳細なカバレッジレポートが必要な場合に利用できます。

## 6. テスト導入のステップ (提案)

1. **JestとReact Testing Libraryの導入**: まずはユニットテストと基本的な統合テストの基盤を構築します。
2. **`ScouterCalculator` のユニットテスト実装**: 戦闘力計算ロジックの正確性を検証します。
3. **フォームコンポーネントのユニットテスト実装**: 入力バリデーションや状態管理のテストを行います。
4. **主要なUIコンポーネントのユニットテスト実装**: レンダリングと基本的な振る舞いをテストします。
5. **統合テストの実装**: ページ間の遷移やコンポーネント間の連携をテストします。
6. **PlaywrightまたはCypressの導入**: E2Eテストの環境を構築します。
7. **主要なユーザーシナリオのE2Eテスト実装**: アプリケーション全体の動作を検証します。
8. **CI/CDパイプラインへのテスト実行の組み込み**: 自動的にテストが実行されるようにします。

## 7. テストに関する考慮事項

- **開発初期からのテスト導入**: 可能な限り早期からテストを導入し、開発と並行してテストコードを作成していくことが理想的です。
- **テスト駆動開発 (TDD)**: 機能実装前にテストコードを書くことで、より質の高いコードが書ける可能性があります。
- **継続的なテストの見直しと改善**: アプリケーションの変更に合わせてテストコードも更新し、常に最新の状態を保つ必要があります。
- **チーム内での知識共有**: テストに関する知識やベストプラクティスをチーム内で共有し、テスト文化を醸成します。

## 8. 今後の検討事項

- テスト実行時間の最適化
- より詳細なカバレッジ分析
- スナップショットテストの適切な利用
- アクセシビリティテストの導入
- パフォーマンステストの導入

## 9. まとめ

本要件定義書に基づき、段階的にテストの仕組みを導入することで、「sns-scouter」の品質向上と開発効率の向上を目指します。まずはユニットテストと統合テストの基盤を確立し、その後E2Eテストを導入していくのが現実的なアプローチと考えられます。テストツールの選定は、チームの経験や好みを考慮しつつ、それぞれのツールの特徴を比較検討して決定します。

ーーー上記やり取りを介し、方針を jest で決定ーーー

プロンプト

```
{
~~~馬鹿でかコード~~~
"include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
 "exclude": ["node_modules"]
}

上記のコードを元に、「`src/app/calc/ScouterCalculator.tsx` 内の戦闘力計算関数 (`calculateBattlePower`, `getBattlePower`)」に対するテストを追加したいと思っています。
以下の方針だけ守ってください。
・本プロジェクトでは、jest を使用することにします。
・src/app/calc/ScouterCalculator.tsxと同じ階層にScouterCalculator.test.tsx を作ってテストファイルは置くようにしてください。

これを実装するために必要な手順を考えてください。

この出力結果はコーディングエージェントに渡すために使用されます。

```

はい、承知いたしました。提供されたコードベースと制約条件に基づいて、`src/app/calc/ScouterCalculator.tsx` 内の戦闘力計算関数 (`calculateBattlePower`, `getBattlePower`) に対するテストを追加するために必要な手順をまとめます。

**1. 環境構築 (Jest のインストール)**

まず、Jest がプロジェクトにインストールされていることを確認します。もしインストールされていなければ、以下のコマンドでインストールします。

```bash
pnpm add -D jest @types/jest
# または npm の場合
npm install --save-dev jest @types/jest
```

`@types/jest` は TypeScript で Jest を使用する際に型定義を提供するために必要です。

**2. テストファイル `ScouterCalculator.test.tsx` の作成**

`src/app/calc/ScouterCalculator.tsx` と同じ階層に、テストファイル `ScouterCalculator.test.tsx` を作成します。

```
src/
└── app/
    └── calc/
        ├── ScouterCalculator.tsx
        └── ScouterCalculator.test.tsx  <-- これを作成
```

**3. テストコードの記述 (`ScouterCalculator.test.tsx`)**

`ScouterCalculator.test.tsx` に、`calculateBattlePower` と `getBattlePower` 関数をテストするためのコードを記述します。

```typescript jsx
// src/app/calc/ScouterCalculator.test.tsx

import { calculateBattlePower, getBattlePower } from './ScouterCalculator'; // 相対パスに注意

describe('ScouterCalculator', () => {
  describe('calculateBattlePower', () => {
    it('should return correct battle power for various follower counts', () => {
      // テストケースの例
      expect(calculateBattlePower(500)).toBe(500);
      expect(calculateBattlePower(1000)).toBe(1500);
      expect(calculateBattlePower(10000)).toBe(20000);
      // ... 他のテストケース
    });

    it('should handle edge cases correctly', () => {
      // 境界値テストの例
      expect(calculateBattlePower(999)).toBe(999);
      expect(calculateBattlePower(1000)).toBe(1500);
      // ... 他の境界値テスト
    });
  });

  describe('getBattlePower', () => {
    it('should return correct battle power', () => {
      // テストケースの例
      expect(getBattlePower(2000)).toBe(3000);
      expect(getBattlePower(50000)).toBe(125000);
      // ... 他のテストケース
    });

    it('should handle invalid input', () => {
      // 無効な入力に対するテスト (必要に応じて)
      expect(getBattlePower(-100)).toBe(0); // 例: 負の値は 0 を返す
    });
  });
});
```

**テストコードのポイント:**

- `import` 文でテスト対象の関数をインポートします。
- `describe` でテストスイート（テストのグループ）を定義します。
- `it` で個別のテストケースを定義します。
- `expect` とマッチャー (`toBe` など) を使用して、期待される結果と実際の値を比較します。
- 境界値テストや無効な入力に対するテストも重要です。

**4. Jest の設定 (`jest.config.js` または `jest.config.ts`)**

必要に応じて、Jest の設定ファイルを作成または修正します。特に TypeScript を使用している場合、`ts-jest` などのプリプロセッサを設定する必要がある場合があります。

```javascript
// jest.config.js (例)
module.exports = {
  preset: 'ts-jest', // TypeScript を使用する場合
  testEnvironment: 'jsdom', // 必要に応じて
  // 他の設定...
};
```

**5. テストの実行**

`package.json` の `scripts` にテスト実行コマンドがあることを確認し、以下のコマンドでテストを実行します。

```bash
pnpm test
# または npm の場合
npm test
```

特定のファイルのみを実行する場合は、ファイルパスを指定します。

```bash
pnpm test src/app/calc/ScouterCalculator.test.tsx
```

**6. テスト結果の確認とリファクタリング**

テスト結果を確認し、失敗するテストがあれば、コードを修正してテストが成功するようにします。また、テストコード自体も、可読性や保守性を高めるためにリファクタリングすることが重要です。

**補足**

- テストケースは、`ScouterCalculator.tsx` の実際のロジックに基づいて、適切に設計する必要があります。
- モックやスパイなどの機能も必要に応じて活用します。
- カバレッジツールを導入して、テストの網羅率を測定することも有効です。

この手順に従って、`ScouterCalculator.tsx` のテストを実装してください。

## 実装記録

### 1. テストコードの作成と改善

1. まず `ScouterCalculator.test.tsx` を作成し、基本的なテストケースを実装
2. テストを実行したところ、期待値と実際の戦闘力計算値の不一致を発見
3. テストケースの期待値を実際の実装に合わせて修正
4. テストの説明を日本語化し、より理解しやすい形に改善
   - 'ScouterCalculator' → 'SNSスカウターのスコア計算ロジック'
   - テストケースの説明も日本語化

### 2. 境界値テストの拡充

以下の境界値テストケースを追加：

1. 最小値周辺のテスト

   - 0フォロワー
   - 1フォロワー
   - 9フォロワー

2. 倍率変更の境界値テスト

   - 999フォロワー（10倍の上限）
   - 1000フォロワー（15倍への変更点）
   - 1001フォロワー（15倍の開始点）

3. 大きな値の境界値テスト

   - 99,999フォロワー
   - 100,000フォロワー
   - 1,000,000フォロワー（100万人）

4. 極端な値のテスト
   - `Number.MAX_SAFE_INTEGER`
   - 負の値
   - NaN

### 3. 実装の改善

テスト実装を通じて以下の実装改善を実施：

1. 大きすぎる値（100万フォロワー超）の場合は0を返すように修正
2. 不正な値（NaN、Infinity）の処理を追加
3. 負の値の処理を追加
4. JavaScriptで安全に扱える最大値を超える場合の処理を追加

### 4. 得られた知見

1. テストを書くことで、実装の不備や考慮漏れを発見できた
2. 境界値テストの重要性を再確認
   - 特にフォロワー数の変化点（1000人）での動作確認が重要
   - 極端な値の処理も考慮する必要がある
3. テストケースの日本語化により、テストの意図がより明確になった
4. テストファーストな開発の利点を体感
   - 実装の要件が明確になる
   - バグの早期発見ができる
   - リファクタリングの安全性が高まる

### 5. 今後の課題

1. テストカバレッジの測定と改善
2. CI/CDパイプラインへのテスト組み込み
3. その他のコンポーネントへのテスト拡充
4. パフォーマンステストの検討
